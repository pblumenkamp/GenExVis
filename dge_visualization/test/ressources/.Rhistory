y.ertrag <- c(22, 17.5, 27, 23, 25, 22.5, 33, 26, 35)
x.dueng <- seq(2.5, 6.5, 0.5)
X.d <- X.d <- matrix(c(rep(1, times=9), x.dueng), byrow=F, ncol=2)
X.d
designmatrix <- function(xx) {                # Argumente festlegen
X.d <- matrix(c(rep(1, times=length(xx)),   # Einsenspalte. Es wird length(xx)Mal die 1 in die erste Spalte geschrieben
xx),                        # Daten
byrow=F, ncol=2)
return(X.d)                                # noetig fuer Ausgabe
}
designmatrix(xx = x.dueng)                    # Funktion auf die Daten anwenden
designmatrix <- function(xx) {                # Argumente festlegen
X.d <- matrix(c(rep(1, times=length(xx)),   # Einsenspalte. Es wird length(xx)Mal die 1 in die erste Spalte geschrieben
xx),                        # Daten
byrow=F, ncol=2)
#return(X.d)                                # noetig fuer Ausgabe
}
(hans<-designmatrix(xx = x.dueng)  )                  # Funktion auf die Daten anwenden -> genau das, wie oben händisch, nur nun automatisiert
designmatrix <- function(xx) {                # Argumente festlegen
X.d <- matrix(c(rep(1, times=length(xx)),   # Einsenspalte. Es wird length(xx)Mal die 1 in die erste Spalte geschrieben
xx),                        # Daten
byrow=F, ncol=2)
return(X.d)                                # noetig fuer direkte Ausgabe. Siehe unten
}
(hans<-designmatrix(xx = x.dueng)  )                  # Funktion auf die Daten anwenden -> genau das, wie oben händisch, nur nun automatisiert
library(MASS)                                    # fuer ginv()
einf.lin.reg <- function(xx, yy) {
X.d <- matrix(c(rep(1, times=length(xx)),       # Designmatrix # Variable wird in Funktion definiert und nicht returned. Die
# Variable kommt hier niemals raus
xx),
byrow=F, ncol=2)
b.v <- ginv(t(X.d) %*% X.d) %*% t(X.d) %*% yy   # Koeffizienten berechnen
return(b.v)                                    # Ausgabe der Koeffizienten
}
einf.lin.reg(xx = x.dueng, yy = y.ertrag)          # Funktion anwenden
library(MASS)                                    # fuer ginv()
einf.lin.reg <- function(xx, yy) {
X.d <- matrix(c(rep(1, times=length(xx)),       # Designmatrix # Variable wird in Funktion definiert und nicht returned. Die
# Variable kommt hier niemals raus.
# Variablen innerhalb der Funktion werden immer nur in der Funktion benutzt. Man kann außerhalb Variablen haben,
# die gleich heißen. Die Funktion nutzt immer die Variablen in sich drin, die außen werden nicht benutzt oder
# überschrieben
xx),
byrow=F, ncol=2)
b.v <- ginv(t(X.d) %*% X.d) %*% t(X.d) %*% yy   # Koeffizienten berechnen
return(b.v)                                    # Ausgabe der Koeffizienten
}
einf.lin.reg(xx = x.dueng, yy = y.ertrag)          # Funktion anwenden
dueng.prog <- c(2, 4, 5.5)
einf.lin.reg.prog <- function(xx, yy, zz) {
X.d <- matrix(c(rep(1, times=length(xx)),       # Designmatrix
xx),
byrow=F, ncol=2)
b.v <- ginv(t(X.d) %*% X.d) %*% t(X.d) %*% yy   # Koeffizienten berechnen
cat("Koeffizienten\n")
print(b.v)                                     # Ausgabe der Koeffizienten. print() liefert keinen Wert zurück. Man kann es nicht in
# einfach in eine Variable <- leiten. Print druckt nur auf die Konsole
cat("___________________\n\n")                # cat() "concatenate and print". Macht das Gleiche wie print, kann nur mehr. Es gibt keine
# Anführungszeichen aus. Cat kann im Gegensatz zu print mehrere Zeilen ausgeben (\n) wird automatisch interpretiert
X.p <- matrix(c(rep(1, times=length(zz)),       # Designmatrix fuer Prognosewerte
zz),
byrow=F, ncol=2)
cat("Designmatrix\n")
print(X.p)                                     # zur Kontrolle
prognose <- X.p %*% b.v                        # Prognose berechnen
return(prognose)                               # Wert ausgeben
}
einf.lin.reg.prog(xx = x.dueng,                   # Funktion anwenden
yy = y.ertrag,
zz = dueng.prog)
einf.lin.reg.prog <- function(xx, yy, zz) {
X.d <- matrix(c(rep(1, times=length(xx)),       # Designmatrix
xx),
byrow=F, ncol=2)
b.v <- ginv(t(X.d) %*% X.d) %*% t(X.d) %*% yy   # Koeffizienten berechnen
cat("Koeffizienten\n")
print(b.v)                                     # Ausgabe der Koeffizienten. print() liefert keinen Wert zurück. Man kann es nicht in
# einfach in eine Variable <- leiten. Print druckt nur auf die Konsole
cat("___________________\n\n")                # cat() "concatenate and print". Macht das Gleiche wie print, kann nur mehr. Es gibt keine
# Anführungszeichen aus. Cat kann im Gegensatz zu print mehrere Zeilen ausgeben (\n) wird automatisch interpretiert
X.p <- matrix(c(rep(1, times=length(zz)),       # Designmatrix fuer Prognosewerte
zz),
byrow=F, ncol=2)
cat("Designmatrix\n")
print(X.p)                                     # zur Kontrolle
prognose <- X.p %*% b.v                        # Prognose berechnen
cat("___________________\n\n")
return(prognose)                               # Wert ausgeben
}
einf.lin.reg.prog(xx = x.dueng,                   # Funktion anwenden
yy = y.ertrag,
zz = dueng.prog)
einf.lin.reg.prog <- function(xx, yy, zz) {
X.d <- matrix(c(rep(1, times=length(xx)),       # Designmatrix
xx),
byrow=F, ncol=2)
b.v <- ginv(t(X.d) %*% X.d) %*% t(X.d) %*% yy   # Koeffizienten berechnen
cat("Koeffizienten\n")
print(b.v)                                     # Ausgabe der Koeffizienten. print() liefert keinen Wert zurück. Man kann es nicht in
# einfach in eine Variable <- leiten. Print druckt nur auf die Konsole
cat("___________________\n\n")                # cat() "concatenate and print". Macht das Gleiche wie print, kann nur mehr. Es gibt keine
# Anführungszeichen aus. Cat kann im Gegensatz zu print mehrere Zeilen ausgeben (\n) wird automatisch interpretiert
X.p <- matrix(c(rep(1, times=length(zz)),       # Designmatrix fuer Prognosewerte
zz),
byrow=F, ncol=2)
cat("Designmatrix\n")
print(X.p)                                     # zur Kontrolle
prognose <- X.p %*% b.v                        # Prognose berechnen
cat("___________________\n\n")
cat("Prognose\n")
return(prognose)                               # Wert ausgeben
}
einf.lin.reg.prog(xx = x.dueng,                   # Funktion anwenden
yy = y.ertrag,
zz = dueng.prog)
A.m <- matrix(c(3, 0, 1, 0, 1, 2, 1, 2, 4)
A.m <- matrix(c(3, 0, 1, 0, 1, 2, 1, 2, 4),
byrow=T,
ncol=3)
A.m <- matrix(c(3, 0, 1, 0, 1, 2, 1, 2, 4),
byrow=T,
ncol=3)
B.m <- matrix(c(1, 0, 0, 0, 2, 0, 1, 2, 0),
byrow=T,
ncol=3)
C.m <-  matrix(rep(1:4, times=2), byrow=T, ncol=4)
A.m
B.m
C.m
mat.f <- function(mat){
rang <- qr(mat)$rank
determinante <- det(mat)
spur <- sum(diag(mat))
inverse <- solve(mat)
return(list(Rang = rang,
Determinante = determinante,
Spur = spur,
Inverse = inverse))
}
mat.f(A.m)
mat.f <- function(mat){
rang <- qr(mat)$rank
determinante <- det(mat)
spur <- sum(diag(mat))
inverse <- solve(mat)
return(list(Hans = rang,
Determinante = determinante,
Spur = spur,
Inverse = inverse))
}
mat.f(A.m)
mat.f(B.m)
mat.f <- function(mat){
rang <- qr(mat)$rank
determinante <- det(mat)
spur <- sum(diag(mat))
if(determinante != 0) {
inverse <- solve(mat)
hinweis <- "Es wurde die echte Inverse berechnet."
} else {
inverse <- ginv(mat)
hinweis <- "Es wurde die Penrose-Moore-Inverse berechnet."
}
return(list(Rang = rang,
Determinante = determinante,
Spur = spur,
Inverse = inverse,
Hinweis = hinweis))
}
mat.f(A.m)
mat.f(B.m)
mat.f(C.m)
mat.f <- function(mat){
rang <- qr(mat)$rank
if (nrow(mat)==ncol(mat)) {
determinante <- det(mat)
spur <- sum(diag(mat))
if (determinante != 0) {
inverse <- solve(mat)
hinweis <- "Es wurde die echte Inverse berechnet."
} else {                                                # if invertierbar
inverse <- ginv(mat)
hinweis <- "Es wurde die Penrose-Moore-Inverse berechnet."
}                                                       # else invertierbar
return(list(Rang = rang,
Determinante = determinante,
Spur = spur,
Inverse = inverse,
Hinweis = hinweis))
} else {                                                  # if quadratisch
return (paste("Der Rang der Matrix ist ", rang, ". Spur, Determinante und Inverse wurden nicht berechnet, da es sich nicht um eine quadratische Matrix handelt.", sep=""))
}                                                         # else quadratisch
}
mat.f(A.m)
mat.f(C.m)
mat.f <- function(mat){
rang <- qr(mat)$rank
# link im Skript für boolsche Operatoren
# if quadratisch = TRUE
if (nrow(mat)==ncol(mat)) {
determinante <- det(mat)
spur <- sum(diag(mat))
# if: invertierbar =TRUE
if (determinante != 0) {
inverse <- solve(mat)
hinweis <- "Es wurde die echte Inverse berechnet."
# else: nicht invertierbar = TRUE
} else {
inverse <- ginv(mat)
hinweis <- "Es wurde die Penrose-Moore-Inverse berechnet."
}
return(list(Rang = rang,
Determinante = determinante,
Spur = spur,
Inverse = inverse,
Hinweis = hinweis))
# WICHTIG: Return bricht Funktion ab
# else: nicht quadratisch, ncol != nrow = TRUE
} else {
return (cat("Der Rang der Matrix ist ", rang, ".\n Spur, Determinante und Inverse wurden nicht berechnet, da es sich nicht um eine quadratische Matrix handelt.", sep=""))
}
}
mat.f(C.m)
set.seed(13)                    # Startpunkt fuer Ziehen von Zufallszahlen
for (i in 1:10) {
summe <- sum(sample(1:10, 2)) # Summe zweier Zahlen von 1 bis 10
print(summe)                  # Ausgabe
}
for(i in 1:10) print(i)
for(i in c(2,4,6,8,10)) print(i)
for (i in 1:10) {
summe <- sum(sample(1:10, 2)) # Summe zweier Zahlen von 1 bis 10
print(summe)                  # Ausgabe
}
set.seed(13)
ergebnis <- NULL # Ergebnisvektor muss vorher erstellt werden.
for (i in 1:10) {
summe <- sum(sample(1:10, 2))  # Summe zweier Zahlen von 1 bis 10
ergebnis <- c(ergebnis, summe) # Ergebnis in Vektor schreiben
}
ergebnis
eins.bis.zehn <- 1:10
ergebnis <- matrix(NA, ncol=10, nrow=10)
for (j in eins.bis.zehn) {
ergebnis[j,] <- j * eins.bis.zehn
}
ergebnis
eins.bis.zehn <- 1:10
for(j in eins.bis.zehn){
ergebnis[j,] <- j* eins.bis.zehn
}
egebnis
ergebnis
ergebnis <- matrix(NA, ncol=10, nrow=10)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("DESeq2")
library("DESeq2")
d.raw <- read.csv("counts_CDS.txt", header=TRUE, row.names=1, sep='\t', comment.char= '#')
setwd("~/Dokumente/master_git/dge_visualization_site/dge_visualization/test/ressources")
d.raw <- read.csv("counts_CDS.txt", header=TRUE, row.names=1, sep='\t', comment.char= '#')
d <- as.matrix(d.raw[, 6:14])
colnames(d) <- c("Untreated_1", "Untreated_2", "Untreated_3", "Erythromycin_1", "Erythromycin_2", "Erythromycin_3", "Clindamycin_1", "Clindamycin_2", "Clindamycin_3")
condition <- as.factor(c("Untreated", "Untreated", "Untreated", "Erythromycin", "Erythromycin", "Erythromycin", "Clindamycin", "Clindamycin", "Clindamycin"))
cData <- data.frame(row.names=colnames(d), condition)
dds <- DESeqDataSetFromMatrix(countData=d, colData=cData, design=~condition)
d.deseq <- DESeq(object=dds)
dds <- estimateSizeFactors(dds)
write.csv(counts(dds, normalized=TRUE), file="counts_normalized.txt")
